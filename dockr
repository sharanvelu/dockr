#!/bin/bash

## Dockr by Sharan

CLR='\033[0m'
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'
CYAN='\033[1;36m'

# Dockr Dir
DOCKR_HOME_DIR="$HOME/dockr"
DOCKR_COMPOSE_ASSET="${DOCKR_HOME_DIR}/dockr-compose-asset.yml"
DOCKR_COMPOSE="${DOCKR_HOME_DIR}/res/dockr-compose.yml"

# Dockr Network
export DOCKR_NETWORK="dockr"

# Project Root Dir
PROJECT_ROOT_DIR="$(pwd)"
export PROJECT_ROOT_DIR

# Project Name
PROJECT_NAME=$(basename "${PROJECT_ROOT_DIR}")
PROJECT_NAME=${PROJECT_NAME// /-}
PROJECT_NAME=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]')
export PROJECT_NAME

# Dockr Asset Project Name
DOCKR_ASSET_PROJECT_NAME="dockr_asset"

# Dockr Asset Credentials
export DOCKR_ASSET_USERNAME="dockr"
export DOCKR_ASSET_PASSWORD="password"
export DOCKR_ASSET_DEFAULT_DATABASE="dockr"

# Source the ".env" file so Laravel's environment variables are available
if [ -f "${PROJECT_ROOT_DIR}/.env" ]; then
    source "${PROJECT_ROOT_DIR}/.env"
fi

# Container Name
export DOCKR_CONTAINER_NAME=${DOCKR_CONTAINER_NAME:-"${PROJECT_NAME}-web"}

# Define custom environment variables
export DOCKR_PHP_VERSION=${DOCKR_PHP_VERSION:-8.0}
if [ -z "${DOCKR_DOCKER_IMAGE}" ]; then
    DOCKR_DOCKER_IMAGE="sharanvelu/laravel-php:${DOCKR_PHP_VERSION}"
fi
export DOCKR_DOCKER_IMAGE

# Docker Compose file.
DOCKER_COMPOSE_FILE="${DOCKR_COMPOSE}"
if [ -n "${DOCKR_CUSTOM_COMPOSE_FILE}" ]; then
    DOCKER_COMPOSE_FILE="$(pwd)/${DOCKR_CUSTOM_COMPOSE_FILE}"
    if [ ! -f "${DOCKER_COMPOSE_FILE}" ]; then
        echo -e "${BLUE}Docker Compose File${CLR} Specified in ${YELLOW}DOCKR_DOCKER_COMPOSE_FILE${CLR} does not exist."
        echo -e "Please check whether the file ${YELLOW}\"${DOCKER_COMPOSE_FILE}\"${CLR} exists."

        exit 1
    fi
    echo ''
fi
export DOCKER_COMPOSE_FILE


# Checks For the working of Docker Engine...
is_docker_engine_up() {
    if ! docker info > /dev/null 2>&1; then
        echo -e "${WHITE}Docker is not running.${CLR}" >&2

        exit 1
    fi
}

# Checks For Dockr Running...
is_dockr_up() {
    # If needs to skip checking for dockr and
    if [ -z "${DO_NOT_CHECK_DOCKR}" ]; then
        if docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" ps | grep -q web
        then
            # Check if there is exited web containers
            EXITED_STATE="$(docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" ps | grep web | grep exited)"
            if [ -n "${EXITED_STATE}" ]; then
                dockr_container_is_stopped

            elif [ -n "$(docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" ps -q)" ]; then
                cat null > /dev/null 2>&1
                TERMINATE_EXECUTION=1
            fi
        fi
        if [ -z "${TERMINATE_EXECUTION}" ]; then
            dockr_is_down
        fi
    fi
}

# Checks For Dockr Asset Containers...
is_dockr_asset_up() {
    # If needs to skip checking for dockr and
    if [ -z "${DO_NOT_CHECK_DOCKR}" ]; then
        # Check if Docker asset containers are up (To avoid "not found" result in CLI)
#        if ! docker-compose ls | grep "${DOCKR_ASSET_PROJECT_NAME}" >> /dev/null
#        then
#            dockr_asset_container_not_running "$1"
#        fi

        if docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" ps | grep -q "$1"
        then
            # Check if there is exited mysql containers
            EXITED_STATE="$(docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" ps | grep "$1" | grep exited)"
            if [ -n "${EXITED_STATE}" ]; then
                dockr_asset_container_is_stopped "$1"
            fi
        else
            dockr_asset_container_not_running "$1"
        fi
    fi
}

# Function that output Dockr container is not running.
dockr_is_down() {
    echo -e "${RED}No ${WHITE}Dockr container is running.${CLR}" >&2
    echo "" >&2
    echo -e "${WHITE}You can run Dockr using any one of the following commands:${CLR}" >&2
    echo -e "${YELLOW}\"dockr up\" ${WHITE}For Normal Mode${CLR}  or" >&2
    echo -e "${YELLOW}\"dockr up -d\" ${WHITE}For Detached Mode${CLR}" >&2

    exit 1
}

# Function that output Dockr container is not running.
dockr_asset_container_not_running() {
    echo -e "${WHITE}Dockr Asset container \"$1\" is ${RED}not running.${CLR}" >&2
    echo "" >&2
    echo -e "${WHITE}You can run Dockr asset container using the following command:${CLR}" >&2
    echo -e "${YELLOW}\"dockr asset up\"${CLR}" >&2

    exit 1
}

# Function that output Dockr container is stopped and not terminated.
dockr_container_is_stopped() {
    echo -e "${WHITE}The Dockr container${CLR}(s) ${WHITE}is ${RED}stopped.${CLR}" >&2
    echo "" >&2
    echo -e "${WHITE}You can start the Dockr container${CLR}(s) ${WHITE}using any one of the following commands:${CLR}" >&2
    echo -e "${YELLOW}\"dockr start\" ${CLR}or ${YELLOW}\"dockr up -d\" ${WHITE}For Detached Mode${CLR} or" >&2
    echo -e "${YELLOW}\"dockr up\" ${WHITE}For Normal Mode${CLR}" >&2

    exit 1
}

# Function that output Dockr container is stopped and not terminated.
dockr_asset_container_is_stopped() {
    echo -e "${WHITE}The Dockr asset container \"$1\" is ${RED}stopped.${CLR}" >&2
    echo "" >&2
    echo -e "${WHITE}You can start the Dockr asset container${CLR}(s) ${WHITE}using the following command:${CLR}" >&2
    echo -e "${YELLOW}\"dockr asset up\"${CLR}" >&2

    exit 1
}

# Check for Dockr Network
dockr_network_check() {
    if ! docker network ls | grep -q -w "${DOCKR_NETWORK}"
    then
        docker network create "${DOCKR_NETWORK}" >> /dev/null
        echo -e "${GREEN}Dockr Network Created.${CLR}"
        echo -e ""
    fi
}

# Manage Asset Containers (Mysql, Redis, ...)
asset_container_check() {
    if [ -z "${DOCKR_SKIP_ASSET}" ]; then
        # Check if Docker asset containers are up (To avoid "not found" result in CLI)
#        if ! docker-compose ls | grep "${DOCKR_ASSET_PROJECT_NAME}" >> /dev/null
#        then
#            DOCKR_ASSET_MYSQL_STARTED=1
#            DOCKR_ASSET_POSTGRES_STARTED=1
#            SHOULD_START_ASSET_CONTAINER=1
#        else
            if ! docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" ps | grep mysql | grep -q running
            then
                DOCKR_ASSET_MYSQL_STARTED=1
                SHOULD_START_ASSET_CONTAINER=1
            fi

            if ! docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" ps | grep postgres | grep -q running
            then
                DOCKR_ASSET_POSTGRES_STARTED=1
                SHOULD_START_ASSET_CONTAINER=1
            fi

            if ! docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" ps | grep redis | grep -q running
            then
                SHOULD_START_ASSET_CONTAINER=1
            fi
#        fi

        if [ -n "${SHOULD_START_ASSET_CONTAINER}" ]; then
            echo -e "Starting asset containers..."
            docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" up -d
            echo -e "Asset containers ${GREEN}started${CLR}."
            echo -e ""
        fi
    fi
}

check_project_database() {
    if [ -n "${DOCKR_SKIP_ASSET}" ] || [ -n "${DOCKR_SKIP_DB_CHECK}" ]; then
        echo '' >> /dev/null
    else
        if [ "$DB_CONNECTION" == "mysql" ]; then
            echo -e "Checking for database ${CYAN}${DB_DATABASE}${CLR} presence in Mysql."
            if [ -n "${DOCKR_ASSET_MYSQL_STARTED}" ]; then
                sleep 3
            fi

            # Create DB with specified name is not present.
            if ! docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" exec mysql bash -c "MYSQL_PWD=${DOCKR_ASSET_PASSWORD} mysql -u root -e \"show databases;\"" | grep -q -w "${DB_DATABASE}"
            then
                echo -e "Creating Database ${CYAN}${DB_DATABASE}${CLR}."
                docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" exec mysql bash -c "MYSQL_PWD=${DOCKR_ASSET_PASSWORD} mysql -u root -e \"create database ${DB_DATABASE}\"" >> /dev/null
                docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" exec mysql bash -c "MYSQL_PWD=${DOCKR_ASSET_PASSWORD} mysql -u root -e \"GRANT ALL PRIVILEGES ON ${DB_DATABASE}.* TO '${DOCKR_ASSET_USERNAME}'@'%'\"" >> /dev/null
                echo -e "Database ${YELLOW}${DB_DATABASE}${CLR} created successfully."
            else
                echo -e "Database ${YELLOW}${DB_DATABASE}${CLR} already exists. Skipping..."
            fi

            echo -e ""
        fi

        if [ "$DB_CONNECTION" == "pgsql" ] || [ "$DB_CONNECTION" == "postgres" ]; then
            echo -e "Checking for database ${CYAN}${DB_DATABASE}${CLR} presence in Postgres."
            if [ -n "${DOCKR_ASSET_POSTGRES_STARTED}" ]; then
                sleep 3
            fi

            # Create DB with specified name is not present.
            if ! docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" exec postgres psql -U "${DOCKR_ASSET_USERNAME}" -l | grep -q -w "${DB_DATABASE}"
            then
                echo -e "Creating Database ${CYAN}${DB_DATABASE}${CLR}."
                docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" exec postgres psql -U "${DOCKR_ASSET_USERNAME}" -d "${DOCKR_ASSET_DEFAULT_DATABASE}" -c "create database ${DB_DATABASE}" >> /dev/null
                echo -e "Database ${YELLOW}${DB_DATABASE}${CLR} created successfully."
            else
                echo -e "Database ${YELLOW}${DB_DATABASE}${CLR} already exists. Skipping..."
            fi

            echo -e ""
        fi
    fi
}

# Check Mandatory Environment variables
check_env() {
    # Check for Mandatory Env variables
    if [ -z "${DOCKR_PORT}" ]; then
        echo -e "Required Parameter ${YELLOW}\"DOCKR_PORT\"${CLR} is ${RED}missing${CLR} from ${CYAN}.env${CLR}"

        exit 1
    fi
    export DOCKR_PORT=${DOCKR_PORT:-80}
}

if [ $# -gt 0 ]; then
    is_docker_engine_up

    # Handle Dockr Up Command.
    if [ "$1" == "up" ]; then
        shift 1

        check_env

        dockr_network_check

        asset_container_check

        check_project_database

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" up "$@"

    # Commands for Asset Containers Such as Mysql, Redis, ...
    elif [ "$1" == "down" ]; then
        shift 1

        if [ "$1" == "all" ]; then
            shift 1

            PS_RESULTS=$(docker ps -f "network=${DOCKR_NETWORK}" -q -a)
            if [ -n "${PS_RESULTS}" ]; then
                echo -e "${RED}Stopping${CLR} all containers."
                docker stop ${PS_RESULTS} >> /dev/null
                docker rm ${PS_RESULTS} >> /dev/null

                echo -e "All containers ${GREEN}stopped${CLR} successfully."
            else
                echo -e "${RED}No${CLR} Dockr containers are running."
            fi

            exit 0
        fi

        if [ "$1" == "asset" ]; then
            shift 1

            TERMINATE_ASSET_CONTAINER=1
        fi

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" down "$@"

        if [ -n "${TERMINATE_ASSET_CONTAINER}" ]; then
            echo -e ""
            echo -e "Stopping asset containers..."
            docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" down
            echo -e "Asset containers ${GREEN}stopped${CLR} successfully."
        fi

    # Commands for Asset Containers Such as Mysql, Redis, ...
    elif [ "$1" == "asset" ]; then
        shift 1

        if [ $# -gt 0 ]; then
            # Start the Asset Containers
            if [ "$1" == "up" ]; then
                shift 1

                docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" up -d "$@"

            # Stop the Asset Containers
            elif [ "$1" == "down" ]; then
                shift 1

                docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" down "$@"

            # Handle Other Commands
            else
                docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" "$@"
            fi

        else
            docker-compose -f "${DOCKR_COMPOSE_ASSET}" ps
        fi

    # Run "PHP" Command within web container.
    elif [ "$1" == "php" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            php "$@"

    # Run "Composer" Command within web container.
    elif [ "$1" == "composer" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            composer "$@"

    # Run "./vendor/bin" (Binary) Command within web container.
    elif [ "$1" == "bin" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            ./vendor/bin/"$*"

    # Run" PHP Artisan" Command within web container.
    elif [ "$1" == "artisan" ] || [ "$1" == "art" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            php artisan "$@"

    # Run "PHP Artisan Test" Command within web container.
    elif [ "$1" == "test" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            php artisan test "$@"

    # Initiate a "laravel Tinker" within web container.
    elif [ "$1" == "tinker" ] ; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            php artisan tinker

    # Run "PHP Artisan Migrate" Command within web container.
    elif [ "$1" == "migrate" ] ; then
        shift 1
        is_dockr_up

        MIGRATION_COMMAND="migrate"
        if [ $# -gt 0 ]; then
            MIGRATION_COMMAND="${MIGRATION_COMMAND}:$*"
        fi

        # shellcheck disable=SC2086
        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            php artisan ${MIGRATION_COMMAND}

    # Run "PHP Artisan db:seed" Command along with "--class" flag within web container.
    elif [ "$1" == "seed" ] ; then
        shift 1
        is_dockr_up

        SEEDER_COMMAND="db:seed"
        if [ $# -gt 0 ]; then
            SEEDER_COMMAND="${SEEDER_COMMAND} --class=$1"
        fi

        # shellcheck disable=SC2086
        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            php artisan ${SEEDER_COMMAND}

    # Run artisan make commands within the web container
    elif [ "$1" == "make" ]; then
        shift 1
        is_dockr_up

        # shellcheck disable=SC2086
        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            php artisan make:$*

    # Run artisan queue commands within the web container
    elif [ "$1" == "queue" ]; then
        shift 1
        is_dockr_up

        # shellcheck disable=SC2086
        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            php artisan queue:$*

    # Run "Node" Command within web container.
    elif [ "$1" == "node" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            node "$@"

    # Run "NPM" Command within web container.
    elif [ "$1" == "npm" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            npm "$@"

    # Run "NPX" Command within web container.
    elif [ "$1" == "npx" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            npx "$@"

    # Run "YARN" Command within web container.
    elif [ "$1" == "yarn" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            yarn "$@"

    # Initiate a Bash session within web container.
    elif [ "$1" == "shell" ] || [ "$1" == "bash" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            bash "$@"

    # Run PhpUnit inside the container
    elif [ "$1" == "phpunit" ]; then
        shift 1
        is_dockr_up

        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" exec web \
            ./vendor/bin/phpunit "$@"

    # Initiate a session within mysql container.
    elif [ "$1" == "mysql" ]; then
        shift 1
        is_dockr_asset_up mysql

        docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" exec mysql \
            bash -c "MYSQL_PWD=${DOCKR_ASSET_PASSWORD} mysql -u root $1"

    # Initiate a Redis Session within Redis container.
    elif [ "$1" == "redis" ] ; then
        shift 1
        is_dockr_asset_up redis

        docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" exec redis \
            redis-cli

    # Initiate a Postgres Session within Postgres container with DB specified.
    elif [ "$1" == "postgres" ] ; then
        shift 1
        is_dockr_asset_up postgres

        docker-compose -f "${DOCKR_COMPOSE_ASSET}" -p "${DOCKR_ASSET_PROJECT_NAME}" exec postgres \
            psql -U "${DOCKR_ASSET_USERNAME}" "${1:-postgres}"

    # RUN other Command with docker-compose
    else
        docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" "$@"
    fi

# Execute PS Command if just "dockr" is run.
# This is to avoid confusions from empty screen after executing command.
else
    docker-compose -f "${DOCKER_COMPOSE_FILE}" -p "${PROJECT_NAME}" ps
fi
